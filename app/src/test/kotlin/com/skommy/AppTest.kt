/*
 * This source file was generated by the Gradle 'init' task
 */
package com.skommy

import com.skommy.models.buildSettings
import com.skommy.models.simpleScript
import com.skommy.services.BuildService
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.io.TempDir
import java.io.File
import java.nio.file.Path

class AppTest {

    @TempDir
    lateinit var tempDir: Path

    private lateinit var testDir: File
    private lateinit var buildService: BuildService

    @BeforeEach
    fun setUp() {
        testDir = tempDir.toFile()
        buildService = BuildService()
    }

    @AfterEach
    fun tearDown() {
        // Clean up any test files
        val configFile = File(testDir, "lizz.yaml")
        if (configFile.exists()) {
            configFile.delete()
        }
    }

    @Test
    fun `test BuildSettingsService save and load functionality`() {
        println("[DEBUG_LOG] Testing BuildSettingsService save and load functionality")

        // Create test build settings
        val originalSettings = buildSettings(
            name = "test-project",
            version = "1.0.0",
            description = "A test project",
            author = "Test Author",
            dependencies = listOf("com.google.code.gson:gson:2.10.1", "org.junit.jupiter:junit-jupiter:5.8.2"),
            scripts = mapOf(
                "test" to simpleScript("./gradlew test"),
                "build" to simpleScript("./gradlew build")
            )
        )

        // Test save functionality
        assertFalse(buildService.yamlExists(testDir), "Config file should not exist initially")

        buildService.save(originalSettings, testDir)

        assertTrue(buildService.yamlExists(testDir), "Config file should exist after save")

        // Test load functionality
        val configFile = File(testDir, "lizz.yaml")
        val loadedSettings = buildService.load(configFile)

        // Verify loaded settings match original
        assertEquals(originalSettings.project.name, loadedSettings.project.name)
        assertEquals(originalSettings.project.version, loadedSettings.project.version)
        assertEquals(originalSettings.project.description, loadedSettings.project.description)
        assertEquals(originalSettings.project.author, loadedSettings.project.author)
        assertEquals(originalSettings.kotlin.version, loadedSettings.kotlin.version)
        assertEquals(originalSettings.dependencies, loadedSettings.dependencies)
        assertEquals(originalSettings.scripts.size, loadedSettings.scripts.size)

        println("[DEBUG_LOG] BuildSettingsService test completed successfully")
    }

    @Test
    fun `test buildSettings helper function`() {
        println("[DEBUG_LOG] Testing buildSettings helper function")

        val settings = buildSettings(
            name = "helper-test",
            version = "2.0.0",
            author = "Helper Author",
            dependencies = listOf("org.jetbrains.kotlin:kotlin-stdlib:1.8.0")
        )

        assertNotNull(settings)
        assertEquals("helper-test", settings.project.name)
        assertEquals("2.0.0", settings.project.version)
        assertEquals("Helper Author", settings.project.author)
        assertEquals("", settings.project.description) // default value
        assertEquals(BuildConstants.MAIN_KT_CLASS, settings.project.mainClass) // default value
        assertEquals(BuildConstants.KOTLIN_VERSION, settings.kotlin.version) // default value
        assertEquals(1, settings.dependencies.size)
        assertTrue(settings.scripts.isEmpty()) // default value

        println("[DEBUG_LOG] buildSettings helper function test completed successfully")
    }

    @Test
    fun `test kotlinHome configuration override`() {
        println("[DEBUG_LOG] Testing kotlinHome configuration override")

        // Test with custom kotlinHome
        val customKotlinHome = "/custom/path/to/kotlin"
        val settingsWithCustomHome = buildSettings(
            name = "kotlin-home-test",
            version = "1.0.0",
            author = "Test Author",
            kotlinHome = customKotlinHome,
            dependencies = emptyList()
        )

        // Verify that the custom kotlinHome is set in settings
        assertEquals(customKotlinHome, settingsWithCustomHome.kotlin.kotlinHome)

        // Test CompilerConstants.getKotlinHome with settings
        val resolvedKotlinHome = CompilerConstants.getKotlinHome(settingsWithCustomHome)
        assertEquals(customKotlinHome, resolvedKotlinHome)

        // Test CompilerConstants.getStdLib with settings
        val expectedStdLibPath = "$customKotlinHome/lib/kotlin-stdlib.jar"
        val resolvedStdLibPath = CompilerConstants.getStdLib(settingsWithCustomHome)
        assertEquals(expectedStdLibPath, resolvedStdLibPath)

        // Test with empty kotlinHome (should fallback to environment)
        val settingsWithEmptyHome = buildSettings(
            name = "empty-home-test",
            version = "1.0.0",
            author = "Test Author",
            kotlinHome = "", // Empty string should trigger fallback
            dependencies = emptyList()
        )
        val fallbackKotlinHome = CompilerConstants.getKotlinHome(settingsWithEmptyHome)
        val fallbackStdLib = CompilerConstants.getStdLib(settingsWithEmptyHome)

        // These should use the environment variable
        assertNotNull(fallbackKotlinHome)
        assertTrue(fallbackStdLib.contains("kotlin-stdlib.jar"))

        // Test save and load with custom kotlinHome
        buildService.save(settingsWithCustomHome, testDir)
        val configFile = File(testDir, "lizz.yaml")
        val loadedSettings = buildService.load(configFile)

        // Verify kotlinHome is preserved after save/load
        assertEquals(customKotlinHome, loadedSettings.kotlin.kotlinHome)

        println("[DEBUG_LOG] kotlinHome configuration override test completed successfully")
    }

    @Test
    fun `test YAML loading without home field`() {
        println("[DEBUG_LOG] Testing YAML loading without home field")

        // Create a YAML file without the home field
        val yamlContent = """
            project:
              name: "test-project"
              version: "1.0.0"
              author: "Test Developer"
              description: "Test project without home field"

            kotlin:
              version: "2.2.0"

            dependencies: []

            scripts: {}
        """.trimIndent()

        val configFile = File(testDir, "lizz.yaml")
        configFile.writeText(yamlContent)

        // Test that loading works without the home field
        val loadedSettings = buildService.load(configFile)

        // Verify that kotlinHome defaults to empty string
        assertEquals("", loadedSettings.kotlin.kotlinHome, "kotlinHome should default to empty string when not specified")

        // Verify other fields are loaded correctly
        assertEquals("test-project", loadedSettings.project.name)
        assertEquals("1.0.0", loadedSettings.project.version)
        assertEquals("Test Developer", loadedSettings.project.author)
        assertEquals("2.2.0", loadedSettings.kotlin.version)

        // Test that CompilerConstants handles empty kotlinHome correctly (fallback to environment)
        val resolvedHome = CompilerConstants.getKotlinHome(loadedSettings)
        val envKotlinHome = CompilerConstants.getKotlinHome()
        assertEquals(envKotlinHome, resolvedHome, "Should fallback to environment KOTLIN_HOME when kotlinHome is empty")

        val resolvedStdLib = CompilerConstants.getStdLib(loadedSettings)
        val expectedStdLib = "$envKotlinHome/lib/kotlin-stdlib.jar"
        assertEquals(expectedStdLib, resolvedStdLib, "Should use environment KOTLIN_HOME for stdlib path when kotlinHome is empty")

        println("[DEBUG_LOG] YAML loading without home field test completed successfully")
    }

    @Test
    fun `test conditional reflection JAR inclusion`() {
        println("[DEBUG_LOG] Testing conditional reflection JAR inclusion")

        // Test 1: Default behavior (reflection = false)
        val settingsDefault = buildSettings(
            name = "reflection-test",
            version = "1.0.0",
            author = "Test Author",
            dependencies = emptyList()
        )

        // Verify reflection property defaults to false
        assertFalse(settingsDefault.kotlin.reflection, "Reflection should default to false")

        // Test DependencyService with default settings
        val dependencyService = com.skommy.services.DependencyService(projectRoot = testDir)
        val classpathDefault = dependencyService.getCompilationClasspath(settingsDefault)

        // Should contain stdlib but not reflection
        assertTrue(classpathDefault.any { it.contains("kotlin-stdlib.jar") }, "Should contain kotlin-stdlib.jar")
        assertFalse(classpathDefault.any { it.contains("kotlin-reflect.jar") }, "Should NOT contain kotlin-reflect.jar by default")

        println("[DEBUG_LOG] Default classpath size: ${classpathDefault.size}")
        classpathDefault.forEach { println("[DEBUG_LOG] Default - $it") }

        // Test 2: Reflection enabled
        val settingsWithReflection = buildSettings(
            name = "reflection-test",
            version = "1.0.0",
            author = "Test Author",
            dependencies = emptyList(),
            reflection = true
        )

        // Verify reflection property is set to true
        assertTrue(settingsWithReflection.kotlin.reflection, "Reflection should be true when explicitly set")

        val classpathWithReflection = dependencyService.getCompilationClasspath(settingsWithReflection)

        // Should contain both stdlib and reflection
        assertTrue(classpathWithReflection.any { it.contains("kotlin-stdlib.jar") }, "Should contain kotlin-stdlib.jar")
        assertTrue(classpathWithReflection.any { it.contains("kotlin-reflect.jar") }, "Should contain kotlin-reflect.jar when enabled")

        println("[DEBUG_LOG] Reflection classpath size: ${classpathWithReflection.size}")
        classpathWithReflection.forEach { println("[DEBUG_LOG] Reflection - $it") }

        // Verify classpath size difference
        assertEquals(classpathDefault.size + 1, classpathWithReflection.size, "Reflection classpath should have one more entry")

        // Test 3: Test CompilerConstants.getReflect method
        val customKotlinHome = "/custom/kotlin/path"
        val settingsWithCustomHome = buildSettings(
            name = "custom-home-test",
            version = "1.0.0",
            author = "Test Author",
            kotlinHome = customKotlinHome,
            dependencies = emptyList(),
            reflection = true
        )

        val expectedReflectPath = "$customKotlinHome/lib/kotlin-reflect.jar"
        val actualReflectPath = CompilerConstants.getReflect(settingsWithCustomHome)
        assertEquals(expectedReflectPath, actualReflectPath, "getReflect should use custom kotlin home")

        // Test 4: YAML serialization/deserialization with reflection
        buildService.save(settingsWithReflection, testDir)
        val configFile = File(testDir, "lizz.yaml")
        val loadedSettings = buildService.load(configFile)

        // Verify reflection property is preserved after save/load
        assertTrue(loadedSettings.kotlin.reflection, "Reflection property should be preserved after save/load")

        println("[DEBUG_LOG] Conditional reflection JAR inclusion test completed successfully")
    }
}
